\chapter{Projekt systemu}
\label{ch:projekt_systemu}

System informatyczny będący tematem pracy inżynierskiej został zrealizowany w architekturze
wielowarstwowej.
W dalszych sekcjach znajduje się szczegółowy opis każdej z warstw.
Przedstawione zostały poziomy dostępu użytkowników, modele danych,
wykorzystane wzorce projektowe, zabezpieczenia aplikacji oraz sposoby przepływu informacji
w przekroju całego systemu informatycznego.
Ogólny schemat przepływu danych pomiędzy elementami systemu został przedstawiony
na rysunku~\ref{fig:arch}.

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.59]{figures/arch.png}
  \caption{Schemat przepływu danych pomiędzy elementami systemu}
  \label{fig:arch}
\end{figure}
\newpage

\section{Poziomy dostępów}
\label{sec:przypadki_uzycia}

W zaprojektowanym systemie istnieje kilka poziomów dostępów dla użytkownika.
Poszczególne poziomy dostępów to:
\begin{itemize}
  \item \textbf{Poziom Gościa}.
  Poziom dostępu przypisywany dla niezalogowanych użytkowników.
  \item \textbf{Poziom Klienta}.
  Jest przypisywany do zalogowanych użytkowników, których konto ma przypisany
  poziom dostępu klienta.
  Umożliwia dostęp do danych związanych z danym kontem i ich ograniczoną modyfikację.
  \item \textbf{Poziom Administratora}.
  Jest przypisywany do zalogowanych użytkowników, których konto ma
  przypisany poziom dostępu administratora.
  Umożliwia dostęp do danych o użytkownikach i kontenerach oraz modyfikację tych danych.
\end{itemize}

Wszystkie przypadki użycia dla poszczególnych poziomów dostępów przedstawia
tabela~\ref{tab:przypadki_uzycia}.
Litery G, K, A oznaczają odpowiednio poziomy dostępów Gościa, Klienta i Administratora.

\newpage
\begin{table}[H]
  \centering
  \caption{Macierz decyzyjna przypadków użycia}
  \begin{tabular}{|r|l|c|c|c|}
    \hline
    Lp. & Przypadek użycia & G & K & A \\
    \hline
    1 & Zaloguj & X & &  \\
    \hline
    2 & Wyloguj & & X & X \\
    \hline
    3 & Utwórz konto & & & X \\
    \hline
    4 & Wyświetl listę wszystkich użytkowników & & & X \\
    \hline
    5 & Usuń konto użytkownika & & & X \\
    \hline
    6 & Wyświetl dane swojego konta & & X & X \\
    \hline
    7 & Wyświetl dane dowolnego konta & & & X \\
    \hline
    8 & Wyświetl listę kontenerów przypisanych do swojego konta & & X & X \\
    \hline
    9 & Wyświetl listę wszystkich kontenerów & & & X \\
    \hline
    10 & Wyświetl status kontenera przypisanego do swojego konta & & X & X \\
    \hline
    11 & Wyświetl status kontenera przypisanego do dowolnego konta & & & X \\
    \hline
    12 & Uruchom kontener przypisany do swojego konta & & X & X \\
    \hline
    13 & Uruchom kontener przypisany do dowolnego konta & & & X \\
    \hline
    14 & Wyłącz kontener przypisany do swojego konta & & X & X \\
    \hline
    15 & Wyłącz kontener przypisany do dowolnego konta & & & X \\
    \hline
    16 & Modyfikuj dane personalne dowolnego konta & & & X \\
    \hline
    17 & Dodaj poziomy dostępów do dowolnego konta & & & X \\
    \hline
    18 & Usuń poziomy dostępów z dowolnego konta & & & X \\
    \hline
    19 & Modyfikuj dane personalne swojego konta & & X & X \\
    \hline
    20 & Zmień hasło do swojego konta & & X & X \\
    \hline
    21 & Zmień hasło do dowolnego konta & & & X \\
    \hline
    22 & Pobierz informacje adresowe o serwerze dla kontenerów LXC & & X & X \\
    \hline
    23 & Wyświetl listę utworzonych zadań zleconych ze swojego konta & & X & X \\
    \hline
    24 & Wyświetl listę utworzonych zadań zleconych z dowolnego konta & & & X \\
    \hline
    25 & Połącz z gniazdem z danymi o stanie wszystkich zadań & & & X \\
    \hline
    26 & Połącz z gniazdem z danymi stanie zadań dla swojego konta & & X & \\
    \hline
    27 & Rozłącz z gniazdem przesyłającym informacje o stanie zadań & & X & X \\
    \hline
  \end{tabular}
  \label{tab:przypadki_uzycia}
\end{table}

\section{Serwer LXC}
\label{sec:serwer_lxc}

W skład warstwy danych projektu pracy inżynierskiej wchodzą dwa systemy informatyczne.
Pierwszy z nich to serwer odpowiedzialny za składowanie kontenerów LXC\@.
Kontenery LXC stanowią część systemu operacyjnego.
Z tego powodu nie mogą być w prosty sposób przechowywane w bazach danych, które specjalizują
się w przechowywaniu innych typów danych.

Aby rozwiązać ten problem w projekcie pracy inżynierskiej, podjęto decyzje o wykorzystaniu
osobnego serwera, którego zadaniem byłoby składowanie kontenerów.
W poniższych podsekcjach opisano technologię kontenerów Linux oraz wymaganą konfigurację serwera,
która umożliwia jego integrację z pozostałymi modułami projektu.

\subsection{Kontenery Linux}
\label{subsec:kontenery_linux}

Konteneryzacja jest kolejnym logicznym krokiem w rozwoju technologii wirtualizacji.
Kontenery dostarczają mechanizm wirtualizacji na poziomie systemu operacyjnego, jak również
na poziomie aplikacji.
Projekt pracy inżynierskiej wykorzystuje technologię konteneryzacji na poziomie systemu
operacyjnego opartego o jądro Linux.

Główne zalety kontenerów Linux to:

\begin{itemize}
  \item Dostarczają kompletne środowisko systemu operacyjnego, które jest izolowane.
  \item Umożliwiają opakowanie i izolację aplikacji wraz z ich całym środowiskiem uruchomieniowym.
  \item Dostarczają przenośne i lekkie środowisko aplikacyjne.
  \item Pomagają w lepszym wykorzystaniu zasobów w centrach danych.
  \item Ułatwiają tworzenie środowisk testowych i produkcyjnych podczas implementacji
  systemów informatycznych.
\end{itemize}

Kontener może być zdefiniowany jako osobny obraz systemu operacyjnego, zawierający izolowany
zestaw aplikacji oraz ich zależności, dzięki któremu mogą one być odseparowane od
maszyny gospodarza.
Może istnieć wiele kontenerów działających jednocześnie w obrębie jednej maszyny gospodarza.

Kontenery dzielą się na dwa typy:

\begin{itemize}
  \item \textbf{Kontenery na poziomie systemu operacyjnego}.
  Cały system operacyjny działa w izolowanym środowisku na maszynie gospodarza, współdzieląc
  to samo jądro systemu.
  \item \textbf{Kontenery na poziomie aplikacyjnym}.
  Aplikacja lub serwis i minimalny zestaw procesów wymaganych przez tą aplikacje, działa
  w izolowanym środowisku na maszynie gospodarza.
\end{itemize}

Konteneryzacja różni się od tradycyjnej technologii wirtualizacji i oferuje wiele dodatkowych
zalet w porównaniu do tradycyjnej wirtualizacji:

\begin{itemize}
  \item Kontenery są znacznie lżejsze od tradycyjnych maszyn wirtualnych.
  \item Wirtualnie maszyny wymagają warstw emulacji, zarówno sprzętu jak i oprogramowania,
  które pochłaniają więcej zasobów i spowalniają działanie.
  Kontenery nie wymagają warstw emulacji.
  \item Kontenery współdzielą zasoby z maszyną gospodarza, izolując przestrzeń użytkownika
  (ang.\ \textit{user space}) i procesy.
  \item Dzięki lekkości kontenerów, na maszynie gospodarza może ich działać znacznie więcej
  niż tradycyjnych maszyn wirtualnych.
  \item Uruchomienie kontenera jest niemal natychmiastowe, maszyny wirtualne startują
  znacznie wolniej.
\end{itemize}

Poniżej na rysunkach~\ref{fig:vms} i~\ref{fig:lxcs} przedstawiono sposób w jaki tradycyjne
maszyny wirtualne i kontenery Linux są zorganizowanie w systemie operacyjnym gospodarza.

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.75]{figures/vms.png}
  \caption{Maszyny wirtualne}
  \label{fig:vms}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.75]{figures/lxcs.png}
  \caption{Kontenery Linux}
  \label{fig:lxcs}
\end{figure}

W systemie Linux kontenery mogą działać dzięki specyficznym funkcjonalnościom jądra Linux.
Najważniejsze z tych funkcjonaliści to:

\begin{itemize}
  \item \textbf{Grupy kontroli (\textit{cgroups})}.
  Dostarczają mechanizmy grupowania zadań i procesów w hierarchiczne grupy.
  \item \textbf{Przestrzenie nazw (\textit{namespaces})}.
  Dostarczają warstwy abstrakcji dla globalnych zasobów systemu, które będą widoczne
  dla procesów wewnątrz tej samej przestrzeni nazw jako izolowania instancja globalnego
  zasobu.
  \item \textbf{System plików lub \textit{rootfs}}.
  Obraz kontenera posiada własny system plików o własnym rdzeniu (ang.\ \textit{root})
  i strukturze podobnej do systemu plików zamontowanego na każdej maszynie z systemem
  operacyjnym GNU/Linux.
\end{itemize}

\subsection{Konfiguracja}
\label{subsec:konfiguracja}

Serwer LXC odpowiedzialny za składowanie kontenerów powinien spełniać założenia, które
umożliwią integrację z nim poprzez warstwę aplikacji.
Projekt systemu zakłada, że serwer ten spełnia następujące wymogi:

\begin{enumerate}
  \item Serwer jest uruchomiony z zainstalowanym systemem GNU/Linux.
  \item Wersja jądra Linux to przynajmniej wersja 3.8.
  Jest to wymagane do najważniejszych funkcjonalności kontenerów LXC\@.
  \item Serwer jest podłączony do sieci dostępnej dla aplikacji serwerowej.
  \item Serwer ma otwarty port, przez który można połączyć się do niego protokołem SSH.\
  \item Serwer przy próbie połączenia przez SSH wymaga uwierzytelnienia loginem i hasłem.
  \item Serwer ma stworzone dodatkowe konto, które nie jest kontem typu \textit{root}.
  Na to konto realizowanie będą połączenia SSH z aplikacji serwerowej.
  \item Uwierzytelnienie się bezpośrednio na konto typu \textit{root} przez protokół
  SSH jest zablokowane.
  \item Serwer ma zainstalowany program LXD\@.
  Jest on dostępny z poziomu powłoki bash.
  \item Serwer ma stworzony bazowy kontener, na podstawie którego będą tworzone
  inne kontenery.
  \item Bazowy kontener ma stworzonego użytkownika, który nie jest kontem typu \textit{root}.
  Można się do niego połączyć przez SSH podając login i hasło, uwierzytelnianie bezpośrednio na
  konto typu \textit{root} jest zablokowane.
  \item Adres IP serwera, port serwera, dane wymagane do uwierzytelnienia przez SSH do serwera oraz
  dane bazowego kontenera są jawne dla aplikacji serwerowej.
\end{enumerate}

\section{RDBMS}
\label{sec:rdbms}

Poza kontenerami projekt pracy inżynierskiej przechowuje również informacje o kontach użytkowników,
do jakich kontenerów posiadają one dostęp oraz podstawowe dane o tych kontenerach
jak np.\ numery portów\@.
Poniżej na rysunku~\ref{fig:datarel} przedstawiono relacje pomiędzy tymi danymi.

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.75]{figures/datarel.png}
  \caption{Relacje między strukturami danych}
  \label{fig:datarel}
\end{figure}

Z tego powodu w skład warstwy danych projektu pracy inżynierskiej wchodzi również drugi system.
Jest to system zarządzania relacyjną bazą danych, inaczej
RDBMS (ang.\ \textit{Relational Database Management System}).
RDBMS dostarcza narzędzia potrzebne do interakcji z bazami danych, np.\ poprzez dostarczoną
implementację specyfikacji języka SQL\@.
Dodatkowo zawiera mechanizmy pozwalające zachować integralność danych.
Najważniejszym takim mechanizmem są transakcje bazodanowe i blokady optymistyczne, które opisano
bardziej szczegółowo w następnych podsekcjach.

\subsection{Transakcje bazodanowe}
\label{subsec:transakcje}

Transakcje bazodanowe to zbiór operacji, które muszą być wykonane jako całość albo wcale.
Celem transakcji jest zapewnienie integralności danych.
Jeśli podczas wykonywania transakcji wystąpi błąd, wszystkie zmiany są wycofywane.
Dopiero podczas zakończenia transakcji, po weryfikacji poprawności wykonania wszystkich
operacji, zmiany są trwale zapisywane w pamięci.

Aby transakcje można było uznać za bezpieczne, powinny spełniać one zasady ACID\@, które określone
są następująco:

\begin{enumerate}
  \item \textbf{Niepodzielność (ang.\ \textit{atomicity})}.
  Transakcja ma wykonać się w całości albo wcale.
  \item \textbf{Spójność (ang.\ \textit{consistency})}.
  Po zakończeniu transakcji dane w bazie muszą być spójne, spełniać zasady i ograniczenia
  poszczególnych kolumn w tabelach.
  \item \textbf{Izolacja (ang.\ \textit{isolation})}.
  Izolacja określa w jaki sposób transakcje wykonywane współbieżnie oddziałują na siebie.
  Standard SQL definiuje następujące poziomy izolacji:
  \begin{itemize}
    \item Read uncommitted.
    Transakcja może odczytywać dane zmienione przez inne transakcje, które jeszcze się
    nie zakończyły.
    \item Read committed.
    Transakcja może odczytywać tylko te dane, które zostały zapisane przez zakończone
    transakcje.
    \item Repeatable reads.
    Transakcja może odczytywać dane z momentu rozpoczęcia transakcji.
    \item Serializable.
    Transakcje wykonane współbieżnie będą miały ten sam rezultat to transakcje
    wykonywane szeregowo.
  \end{itemize}
  \item \textbf{Trwałość (ang.\ \textit{durability})}.
  Po zakończeniu transakcji jej rezultat zostanie trwale zapisany w bazie danych.
  Przypadki awarii systemu lub braku zasilania muszą być obsługiwane.
\end{enumerate}

\subsection{Blokady optymistyczne}
\label{subsec:optimisticlock}

Projekt pracy inżynierskiej jest z założenia systemem wielodostępowym, w którym wielu
użytkowników może jednocześnie modyfikować te same dane.
Z tego powodu jeden z użytkowników może pracować na nieaktualnych danych, bez wiedzy,
że zostały one zmienione przez innego użytkownika.
Taka sytuacja może naruszyć integralność danych.

Aby rozwiązać ten problem zastosowano mechanizm blokad optymistycznych.
Każda krotka w bazie danych ma pole wersji, które jest inkrementowane wraz
z każdą transakcją, która ją modyfikuje.
Jednocześnie do użytkownika przesyłane są numery wersji dla poszczególnych
danych, odpowiadające numerom wersji krotek w bazie danych w momencie ich odczytu.
Użytkownik po wykonaniu zmian przekazuje ten sam numer wersji.
Jeśli dane ulegną zmianie w trakcie wykonywania jego zmian, przesłany numer wersji nie
będzie zgodny z wersją w bazie danych.
Transakcja nie zakończy się, a użytkownik zostanie poinformowany o tym błędzie i
będzie mógł pobrać dane jeszcze raz w celu aktualizacji danych.

\section{Warstwa aplikacji}
\label{sec:warstwa_apk}

W skład warstwy aplikacji wchodzi aplikacja serwerowa.
Warstwa aplikacji jest odpowiedzialna za integrację z warstwą prezentacji oraz z warstwą danych.
W projekcie pracy inżynierskiej aplikacja serwerowa składa się kilku różnych następujących modułów.
Najważniejsze z modułów aplikacji serwerowej to:

\begin{itemize}
  \item \textbf{Repozytoria}.
  Są odpowiedzialne za komunikację z relacyjną bazą danych.
  Konwertują wywołania metod na odpowiednie zapytania do bazy danych oraz mapują odpowiedzi
  tych zapytań na obiekty.
  \item \textbf{Serwisy}.
  Są odpowiedzialne za logikę biznesową aplikacji.
  Serwisy decydują kiedy metody repozytoriów zostaną wywołanie i w jakim kontekście, ponieważ to one
  przetwarzają dane z tych repozytoriów.
  Są one również odpowiedzialne za nawiązanie połączenia z serwerem do składowania kontenerów LXC\@.
  \item \textbf{Kontrolery}.
  Są odpowiedzialne za wystawianie interfejsów REST\@.
  Konwertują żądania HTTP oraz obiekty encji na obiekty DTO\@.
  Przekazują skonwertowane żądania do serwisów oraz mapują wyniki działań serwisów na obiekty DTO
  i odpowiedzi HTTP\@.
  \item \textbf{Encje}.
  Reprezentują encje w bazach danych w oparciu o adnotacje JPA\@.
  Są to anemiczne obiekty, nieposiadające żadnej logiki poza metodami dostępowymi od poszczególnych
  pól.
  \item \textbf{DTO}\@.
  Oznaczają obiekty które będą przesyłanie pomiędzy warstwą widoku i warstwą
  aplikacji (ang. \textit{Data Transfer Object}).
  Stosuje się je w celu poprawy bezpieczeństwa aplikacji oraz lepszej separacji modułów.
  Obiekty DTO mogą ukrywać niektóre pola obecne w obiektach encji, np.\ skrót hasła lub numer
  identyfikacyjny krotki w bazie danych.
  Podobnie jak encje, są to obiekty anemiczne.
\end{itemize}

Aplikacja serwerowa wykorzystuje wiele technologii.
W następnych podsekcjach opisano dodatkowe szczegóły dotyczące projektu aplikacji serwerowej.

\subsection{Integracja z serwerem LXC}
\label{subsec:intlxc}

Istotnym elementem projektu aplikacji serwerowej było zdefiniowanie komunikacji z serwerem
odpowiedzialnym za składowanie kontenerów Linux.
Serwer ten zarządza kontenerami za pomocą wcześniej opisanego narzędzia LXD, które dostarcza
interfejs dostępny z poziomu linii poleceń.

Z tego powodu aplikacja serwerowa nawiązuje połączenie SSH z serwerem LXC\@.
SSH (ang.\ \textit{Secure Shell}) to protokół umożliwiający wykonywanie zdalnych poleceń powłoki
w bezpieczny, szyfrowany sposób.
Następnie w trakcie trwania sesji połączenia SSH, aplikacja serwerowa wysyła określone polecenia
do zarządzania kontenerami na zdalny serwer.

Polecenia wykonywane na serwerze LXC są zdefiniowane w konfiguracji aplikacji serwerowej
jako ściśle określone szablony.
Szablony tych poleceń mają postać zwykłego łańcucha znaków, który jest odpowiednio formatowany
do potrzeb aktualnie przetwarzanego żądania.
Dzieje się to poprzez zamianę tzw.\ specyfikatorów formatu
(ang.\ \textit{format specifiers}) na odpowiednie wartości, np.\ nazwę kontenera.

\subsection{Integracja z bazą danych}
\label{subsec:intdb}

W warstwie aplikacyjnej wykonywane są operacje na encjach relacyjnej bazy danych.
Aby ułatwić oprogramowanie takich operacji, wykorzystano mechanizm mapowania relacyjno
obiektowego za pomocą interfejsów JPA i implementacji JPA o nazwie
Hibernate.

Połączenie z bazą danych realizowane jest za interfejsu
JDBC (ang. \textit{Java Database Connectivity}).
JDBC definiuje interfejsy określające w jaki sposób klient, czyli tym przypadku aplikacja serwerowa,
może połączyć się do bazy danych.
Każdy system zarządzania bazy danych musi mieć odpowiedni sterownik JDBC czyli
własną implementację tego interfejsu ze względu na różnice w implementacji
każdego systemu RDBMS\@.

\subsection{Interfejs REST}
\label{subsec:intrest}

Aplikacja serwerowa dostarcza własny interfejs dostępny poprzez protokół HTTP, za pomocą którego
inne aplikacje mogą z niego skorzystać.
Architektura tego interfejsu oparta jest o REST (ang.\ \textit{Representational State Transfer}).
REST umożliwia dostęp do zasobów sieciowych za pomocą uniwersalnych i bezstanowych operacji.
W przypadku projektu aplikacji serwerowej, aplikacja kliencka wysyła żądanie HTTP
wraz z odpowiednimi nagłówkami na odpowiedni adres URI\@.

Protokół HTTP przewiduje wiele metod określających typ żądania, które w mają swoje realne
odzwierciedlenie w aplikacji serwerowej przy zastosowaniu architektury REST\@.
Najważniejsze z metod HTTP to:

\begin{itemize}
  \item \textbf{GET}.
  Oznacza żądanie pobrania danych zasobu wskazanego przez adres URI\@.
  \item \textbf{POST}.
  Oznacza żądanie dodania nowego zasobu danymi przesłanego przez klienta.
  \item \textbf{PATCH}.
  Oznacza żądanie aktualizacji zasobu danymi przesłanymi przez klienta.
  \item \textbf{PUT}.
  Oznacza żądanie zamiany danego zasobu nowym zasobem określonym danymi przesłanymi przez klienta.
  \item \textbf{DELETE}.
  Oznacza żądanie usunięcia danych zasobu wskazanego przez adres URI\@.
\end{itemize}

W przypadku zapytań POST, PUT i PATCH wysyłana jest dodatkowa treść żądania.
Serwer odpowiada na te zapytania wysyłając kod odpowiedzi HTTP, definiujący status przetworzonego
żądania oraz ewentualną treść odpowiedzi.
W przypadku realizowanego projektu format treści odpowiedzi i zapytań to JSON\@.

Kody odpowiedzi HTTP są również ściśle zdefiniowane w specyfikacji protokołu HTTP\@.
Kody są 3-cyfrowe, gdzie pierwsza cyfra oznacza kategorię odpowiedzi:

\begin{itemize}
  \item \textbf{1xx}.
  Kody informacyjne, informują o odebraniu żądania, przetwarzanie żądania może wciąż trwać.
  \item \textbf{2xx}.
  Kody dla pomyślnego przetworzenia żądania, informują że żądanie zostało odebrane, zrozumiane i
  i przetworzone.
  \item \textbf{3xx}.
  Kody przekierowania, informują o dodatkowych czynnościach które muszą być podjęte
  aby zakończyć żądanie.
  \item \textbf{4xx}.
  Kody błędu klienta, informują że żądanie wysłane przez klienta zawiera błędy i nie może
  być przetworzone.
  \item \textbf{5xx}.
  Kody błędu serwera, informują, że serwer podczas próby przetworzenia poprawnego żądania napotkał
  na niespodziewany błąd, przez co nie mógł zakończyć pomyślnego przetworzenia tego żądania.
\end{itemize}

\subsection{WebSocket}
\label{subsec:websocket}

Aplikacja serwerowa dostarcza interfejsy do zarządzania kontenerami.
Są one dostępne poprzez opisany wyżej interfejs REST, jednak czas odpowiedzi na żądanie jest
niedeterministyczny.
Z tego powodu po przyjęciu takiego żądania zwracana jest odpowiedź HTTP 202 informująca
użytkownika, że żądanie zostało poprawnie przyjęte do realizacji.
Reszta żądania jest wykonywana asynchronicznie.

Aby powiadomić użytkownika o zakończeniu wykonywania takiego żądania wykorzystano gniazda TCP
za pomocą technologii WebSocket.
Gniazda TCP umożliwiają dwukierunkową komunikację, dzięki temu serwer ma możliwość wysłania
informacji bez wcześniejszego zapytania klienta.
Technologia WebSocket umożliwiła wykorzystanie gniazd TCP w przeglądarkach internetowych
w oparciu o istniejącą infrastrukturę HTTP\@.
Wykorzystanie technologii WebSocket pozwala zmniejszyć obciążenie sieci, serwera oraz przeglądarki
internetowej.

\section{Warstwa widoku}
\label{sec:warstwa_widoku}

Warstwa widoku jest odpowiedzialna za interakcję z użytkownikiem, przesyłaniem jego akcji
do aplikacji serwerowej oraz wyświetlanie danych pobranych z serwera w przystępny dla
człowieka sposób.
W skład warstwy widoku wchodzi aplikacja kliencka działająca w przeglądarce internetowej, wykonana
z użyciem technologii React.
Dzięki zastosowaniu technologii React aplikacja kliencka jest zupełnie odrębną aplikacją,
która komunikuje się warstwą widoku za pomocą zapytań HTTP i technologii WebSocket.

\subsection{SPA}
\label{subsec:spa}

Aplikacja kliencka została wykonana jako aplikacja typu
SPA (ang.\ \textit{Single Page Application}).
SPA to inaczej jednostronicowa aplikacja internetowa.
Strona wykonana w technologii SPA podczas interakcji z użytkownikiem aktualizuje tylko wybrane
elementy na stronie.
Nie ma potrzeby odświeżania całej strony i pobierania całej nowej zawartości na nowo, w tym
danych które nie uległy zmianie i nie wymagają aktualizacji.
Umożliwia to  oszczędzanie zasobów sieci, serwera i aplikacji klienckiej.
Dzięki takiej oszczędności cały system informatyczny działa wydajniej.


\section{Wzorce projektowe}
\label{sec:wzorce_projekctowe}

Podczas implementacji złożonych systemów informatycznych istotną rolę odgrywa struktura kodu
źródłowego oraz zdefiniowanie powiązań i sposobów komunikacji pomiędzy poszczególnymi elementami
tak zdefiniowanej struktury.
Wzorce projektowe są uniwersalnymi i sprawdzonymi metodami rozwiązywania tego typu problemów.
Poniżej zostały opisane najważniejsze ze wzorców, które zostały wykorzystanie podczas projektowania
pracy inżynierskiej.

\subsection{Model-Widok-Kontroler}
\label{subsec:webmvc}

Wzorzec Model-Widok-Kontroler, w skrócie MVC (ang.\ \textit{Model-View-Controller}) to wzorzec
architektoniczny służący do organizowania struktury aplikacji posiadających graficzne interfejsy
użytkownika.
Wzorzec MVC powstał oryginalnie dla aplikacji desktopowych, dlatego w projekcie została
wykorzystana jego zmodyfikowana wersja dla aplikacji internetowych.

Wzorzec MVC dla aplikacji internetowych definiuje strukturę aplikacji podzieloną na trzy części:

\begin{itemize}
  \item \textbf{Model}.
  Reprezentuje logikę biznesową aplikacji.
  \item \textbf{Widok}.
  Jest odpowiedzialny na wyświetlenie graficznego interfejsu użytkownika.
  Wysyła żądania generowane przez użytkownika do kontrolera oraz aktualizuje widoki na podstawie
  odpowiedzi kontrolera na te żądania.
  \item \textbf{Kontroler}.
  Koordynuje komunikację pomiędzy widokiem a modelem.
  Przekazuje żądania wysłane z widoku do modelu oraz przekazuje odpowiedzi na te żądania do widoku
  na podstawie komunikatów z modelu.
\end{itemize}

\subsection{Wstrzykiwanie zależności}
\label{subsec:di}

Wstrzykiwanie zależności (ang.\ \textit{Dependency Injection}) w programowaniu obiektowym
polega na dostarczaniu zależności dla obiektu poprzez inny obiekt.
Dzięki zastosowaniu wzorca wstrzykiwania obiekty są niezależne od sposobów tworzenia
pozostałych obiektów, powiązania pomiędzy obiektami stają się bardziej luźne.
Umożliwia to m.in.\ realizację paradygmatu odwrócenia sterowania
(ang.\ \textit{Inversion of Control}) oraz ułatwia testowanie aplikacji dzięki możliwości
wstrzykiwania atrapy obiektów.

\section{Bezpieczeństwo}
\label{sec:bezpieczenstwo}

System informatyczny dostępny dla wielu użytkowników powinien być zabezpieczony
przed atakami hakerskimi.
Najbardziej powszechnym i podstawowym takim zabezpieczeniem jest mechanizm
uwierzytelniania i autoryzacji.
Istotną rolę pełni również szyfrowanie wrażliwych danych.
Dane wrażliwe powinny być przesłane w postaci niejawnej oraz w ten sam sposób przechowywane
w systemie.
Jednak dzisiejsze systemy informatyczne, a szczególnie te działające za pośrednictwem sieci
internetowej, są narażone na większą ilość zagrożeń.
Zabezpieczenia oraz zagrożenia systemu zrealizowanego w ramach pracy inżynierskiej zostały opisane
w następnych podsekcjach.

\subsection{JWT}
\label{subsec:jwt}

Aplikacja serwerowa jest aplikacją bezstanową.
Bezstanowość aplikacji umożliwia jej łatwiejszą skalowalność, ponieważ kilka różnych instancji
aplikacji może równoważnie obsługiwać żądania od tego samego użytkownika.
Aby to osiągnąć do autoryzacji użytkowników wykorzystano tokeny JWT\@.
Token JWT składa się z trzech części:

\begin{itemize}
  \item \textbf{Nagłówek (ang.\ \textit{header})}.
  Zawiera informacje o tym jaki algorytm został wykorzystany do wygenerowania podpisu cyfrowego.
  \item \textbf{Zawartość (ang.\ \textit{payload})}.
  Zawiera informacje jakie uprawnienia nadaje ten token, np.\ role użytkownika
  czy datę wygenerowania i ważności.
  \item \textbf{Podpis (ang.\ \textit{signature})}.
  Jest to podpis cyfrowy wygenerowany przez serwer na podstawie nagłówka i zawartości oraz
  klucza prywatnego znanego tylko w aplikacji serwerowej.
\end{itemize}

Każda z tych części jest dodatkowo zakodowana algorytmem Base64.
Ostateczna postać tokenu to konkatenacja zakodowanych trzech części, części są odseparowanie od siebie
znakiem pojedynczej kropki:

\begin{equation}
  jwt = header_{b64} + \textrm{,,.''} + payload_{b64} + \textrm{,,.''} + signature_{b64}
\end{equation}

Użytkownik uwierzytelniając się w systemie wysyła tak naprawdę żądanie o wygenerowanie tokenu.
Serwer weryfikuje login i hasło i jeśli są poprawne to generuje token JWT i zwraca go w odpowiedzi.
Klient przechowuje swój token i wysyła go przy każdym następnym żądaniu w nagłówku HTTP\@.
Serwer przy każdym odebranym żądaniu, na samym początku jego przetwarzania weryfikuje podpis
cyfrowy, znajdujący się w przesłanym nagłówku przy użyciu swojego klucza prywatnego.
Jeśli weryfikacja zakończy się powodzeniem, żądanie jest wykonywane dalej.

\subsection{HTTPS}
\label{subsec:https}

Podczas komunikacji aplikacji klienckiej z aplikacją serwerową za pomocą protokołu HTTP,
klient może przesyłać do serwera poufne dane takie jak hasło, które będzie przesyłane w postaci
jawnej nim nie trafi do serwera i zostanie przez niego zaszyfrowanie.
Rozwiązaniem tego problemu jest zastosowanie protokołu HTTPS\@.
Jest to szyfrowana wersja protokołu HTTP\@.
Główną różnicą między protokołem HTTP i HTTPS jest to, że HTTP bazuje
na protokole TCP, natomiast HTTPS bazuje na protokole TLS, który działa na bazie protokołu TCP\@.
TLS zapewnia poufność danych poprzez ich odpowiednie szyfrowanie.

W modelu TCP/IP protokół TLS działa tuż nad warstwą transportową, dzięki czemu nie jest zależny
od sprzętu czy systemu operacyjnego.
Proces nawiązania połączenia TLS między klientem i serwerem wygląda następująco:

\begin{itemize}
  \item Klient wysyła żądanie nawiązania połączenia TLS do serwera i prezentuje swoją listę
  wspieranych algorytmów szyfrujących.
  \item Serwer wybiera algorytm z otrzymanej listy, który jest również wspierany przez niego i
  powiadamia o tym klienta.
  \item Serwer wysyła również do klienta swój certyfikat cyfrowy,
  zawierający klucz publiczny serwera, jego nazwę i urząd certyfikacji, który potwierdza własność
  klucza publicznego dla tego serwera
  \item Klient potwierdza poprawność certyfikatu.
  \item Następnie klient generuje klucze sesyjne.
  Może to się stać poprzez wylosowanie liczby, zaszyfrowanie jej kluczem publicznym serwera i
  wysłanie do serwera.
  Następnie na podstawie tej liczby klient i serwer generują klucz symetryczny,
  który jest wykorzystany do dalszego szyfrowania i deszyfrowania komunikatów w trakcie sesji TLS\@.
\end{itemize}

\subsection{Przetwarzanie danych poufnych}
\label{subsec:szyfrowanie}

Poza zapewnieniem bezpiecznej komunikacji między aplikacją kliencką i serwerową,
dane poufne, które są przetwarzane i przechowywane przez system informatyczny powinny być
przetwarzane w bezpieczny sposób.
W przypadku realizowanego projektu danymi poufnymi są hasła do kont użytkowników.
Powinny być one znane tylko dla właścicieli tych kont.

Brak zabezpieczeń danych poufnych sprawia, że podczas włamania do systemu atakujący może uzyskać
hasła i loginy użytkowników i logować się na ich konta bez ich wiedzy.
Dodatkowo może również włamać się do innych systemów jeśli użytkownik użył tam tego samego hasła.
Dlatego administrator systemu również nie powinien znać tych haseł i powinny być one składowane
w postaci niejawnej.
Aby rozwiązać ten problem, podczas tworzeniu konta do bazy danych zapisywany jest tylko skrót hasła
utworzony za pomocą algorytmu kryptograficznego \textit{bcrypt}.

\subsection{Atak wstrzykiwania kodu}
\label{subsec:atakdi}

W warstwie widoku administrator systemu ma uprawnienia do tworzenia nowych kontenerów.
Podczas tworzenia tych kontenerów podaje jego parametry jak nazwę czy porty.
Następnie te parametry są przekazywane do serwera, serwer wstawia je do szablonów poleceń
i wykonuje na zdalnym zdalnym serwerze poprzez SSH, co zostało opisane we wcześniejszej
sekcji~\ref{subsec:intlxc}.

Tworzy to zagrożenie gdy nie ma walidacji przekazanych parametrów.
Administrator może przekazywane parametry spreparować w taki sposób, że na serwerze zamiast
komendy utworzenia kontenera zostanie wykonana inna, na przykład taka, która usunie wszystkie dane.
Jednak projekt pracy inżynierskiej zakłada, że administrator jest zaufanym użytkownikiem systemu,
który nie ma na celu działania na jego szkodę.
Użytkownik bez uprawnień administratora nie ma możliwości wprowadzania danych, które są następnie
bezpośrednio umieszczanie w linii poleceń, także takie zagrożenie ze strony użytkownika nie istnieje.

Należy jednak zdawać sobie sprawę z takiego zagrożenia, projektując dodatkowe funkcjonaliści systemu
w przyszłości oraz dodając nowych użytkowników z uprawnieniami administratora.

Rozwiązaniem tego problemu w projekcie pracy inżynierskiej jest walidacja przekazanych parametrów,
poprzez wymuszenie jedynie znaków alfanumerycznych w nazwie kontenera oraz znaków numerycznych w
przekazanym porcie.

\subsection{CSRF}
\label{subsec:csrf}

Atak typu CSRF (ang.\ \textit{Cross-Site Request Forgery}) to atak na przeglądarkę internetową.
Nie jest to atak na część serwerową aplikacji internetowej.
Polega na zmuszeniu przeglądarki ofiary do wykonania żądania HTTP w sposób nieautoryzowany.
Ofiara ataku jest zalogowana w przeglądarce, a wymuszone żądanie posiada ciasteczko sesji oraz
pozostałe automatycznie załączone informacje o sesji zalogowanego użytkownika.
Z tego powodu aplikacja serwerowa będzie traktowała takie żądania jako prawdziwe.
Poprzez atak CSRF ofiara ataku może nieumyślnie wykonać jakąś akcje, np.\ zmodyfikować dane swojego
konta lub wykonać przelew pieniędzy.

W przypadku realizowanego projektu, sesja użytkownika nie jest oparta o ciasteczka sesyjne i
inne automatyczne funkcje zaimplementowane w przeglądarkach.
Zamiast tego przy każdym żądaniu do serwera należy dodać nagłówek autoryzacyjny z tokenem JWT oraz
w niektórych przypadkach dodatkowy nagłówek z wersją danych, wykorzystywanego do mechanizmu blokad
optymistycznych.

Brak wykorzystania automatyzmów sesyjnych zaimplementowanych w przeglądarce, pozwala
w podstawowy sposób zabezpieczyć się przed tego typu atakami.
Jednak aby całkowicie zabezpieczyć się przed CSRF, potrzebna jest też ochrona przed atakami XSS,
które zostaną opisane w następnej podsekcji.

\subsection{XSS}
\label{subsec:xss}

Atak XSS podobnie jak CSRF jest to atak na klienta, a nie na część serwerową aplikacji.
Atak polega na wstrzyknięciu do przeglądarki ofiary fragmentu kodu języka skryptowego który
może być wykonany przez przeglądarkę, najczęściej jest to kod JavaScript, powszechnie używany
we wszystkich przeglądarkach.

Podatność na XSS tworzy szereg zagrożeń dla użytkownika.
Atakujący może wykraść sesje użytkownika, podmienić zawartość strony czy
logować wszystkie dane wprowadzane przez użytkownika, w tym hasła.
Dodatkowo podatność na XSS tworzy jednocześnie podatność na CSRF, ponieważ za pomocą języka
skryptowego atakujący może dodać wymagane nagłówki autoryzacyjne, które nie są automatycznie
dodawane przez przeglądarkę.

Istnieje wiele metod zabezpieczanie przed XSS\@, nie wszystkie gwarantują całkowitą ochronę
przed tym atakiem, ale znacząco utrudniają jego przeprowadzenie.
Najpopularniejsze z tych metod to:

\begin{itemize}
  \item Filtracja danych przesłanych przez użytkownika.
  Dotyczy to szczególnie znaków specjalnych jak \textit{>}, \textit{/} czy \textit{"}, które
  są znakami tworzącymi tagi HTML i mogą posłużyć do wstrzyknięcia kodu JavaScript.
  \item Przechowywanie ciastek sesyjnych z tagiem \textit{HttpOnly}.
  Takie ciastka są niedostępne do odczytu z poziomu kodu JavaScript.
\end{itemize}

W przypadku projektu pracy inżynierskiej nie wykorzystywano ciastek sesyjnych z tagiem HttpOnly,
przez co token JWT jest dostępny z poziomu kodu JavaScript.
Podstawowe zabezpieczenie przed atakami XSS umożliwia zastosowanie biblioteki React.
React do tworzenia kodu HTML wykorzystuje składnie JSX\@.
Wszystkie wartości zawarte w kodzie JSX są zamieniane na łańcuchy znaków, co pozwala
w podstawowy sposób zabezpieczyć się przed umieszczeniem tam kodu wykonywalnego.

\clearpage