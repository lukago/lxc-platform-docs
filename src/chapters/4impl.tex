\chapter{Implementacja}
\label{ch:implementacja}

Rozdział ten opisuje implementację opisanego w poprzednim rozdziale projektu.
Zostaną przedstawione szczegóły dotyczące konfiguracji aplikacji,
struktury modeli wykorzystanych w projekcie oraz implementację kluczowych
mechanizmów wraz z fragmentami kodu źródłowego.
Rozdział zawiera również podręcznik użytkownika, opisujący warstwę widoku
i najważniejsze przypadki użycia.

\section{Konfiguracja}
\label{sec:konfiguracja}

Istotną częścią implementacji jest konfiguracja projektu w taki sposób
aby był on jak najbardziej elastyczny i umożliwiał szybkie zbudowanie aplikacji
bez instalowania dodatkowych zależności.
W poniższych podsekcjach opisano konfigurację poszczególnych
wchodzących w skład modułów projektu pracy inżynierskiej.

\subsection{Aplikacja serwerowa}
\label{subsec:konfiguracja-serwera}

Aplikacja serwerowa jest uruchamiana za pomocą technologii \textit{Docker}
wraz z wykorzystaniem narzędzia \textit{docker-compose}.
Dzięki wykorzystaniu tej technologii możliwe jest szybkie uruchomienie
aplikacji wraz ze wszystkimi zależnościami.
Zawartość pliku docker-compose dla aplikacji serwerowej została przedstawiona
poniżej we fragmencie programu~\ref{lst:dockercomposeserver}.

\lstinputlisting[
  caption=Zawartość docker-compose.yml dla aplikacji serwerowej,
  label=lst:dockercomposeserver
]{docker-compose.server.txt}

Powyższa konfiguracja jest przykładowa i wykorzystywana podczas implementacji
na lokalnej maszynie.
Jeśli chcielibyśmy uruchomić aplikację na produkcyjnym serwerze, powyższa
konfiguracja wymagałaby drobnych zmian, np.\ adresu URL warstwy widoku poprzez
wartość \textit{WEBUI\_URL}.
Warto zauważyć że powyższa konfiguracja tworzy również bazę danych
PostgreSQL\@.
Trwałość danych pomiędzy wieloma uruchomieniami narzędzia \textit{Docker}
osiągnięto poprzez zastosowanie wolumenów, określonych w sekcji \textit{volumes}.

Konfiguracja wykorzystuje bazowy obraz \textit{lxc-platform-server:latest}.
Jest on tworzony za pomocą narzędzia\textit{docker} który tworzy obraz na podstawie
pliku \textit{Dockerfile}.
Zawartość pliku Dockerfile została przedstawiona poniżej we
fragmencie~\ref{lst:dockerserver}.

\lstinputlisting[
  caption=Dockerfile aplikacji serwerowej,
  label=lst:dockerserver
]{dockerfile-server.txt}

Konfiguracja \textit{docker-compose} eksportuje zmienne środowiskowe poprzez słowo
kluczowe \textit{environment}.
Są one następnie wykorzystywane w konfiguracji aplikacji szkieletu Spring.
Fragment konfiguracji szkieletu Spring został przedstawiony poniżej~\ref{lst:springconf}.

\lstinputlisting[
  firstline=41,
  lastline=50,
  caption=Frament konfiguracji szkieletu Spring wykorzystujący zmienne środowiskowe,
  label=lst:springconf,
]{application-dev.txt}

Taka konfiguracja umożliwia uniwersalność ponieważ wszystkie wartości związanie
ze środowiskiem aplikacyjnym są eksportowane przez narzędzie \textit{docker-compose}.
Tym samym nie ma potrzeby zmiany zawartości tego pliku czy ponownej kompilacji aplikacji
jeśli zechcemy zainstalować ją w innym środowisku, wystarczy jedynie zmienić wartości
w pliku \textit{docker-compose.yml}.

\subsection{Aplikacja kliencka}
\label{subsec:konfiguracja-widoku}

Podobnie jak aplikacja serwerowa, również aplikacja kliencka wykorzystuje narzędzia
\textit{docker} oraz \textit{docker-compose}.
Konfiguracja zawarta w pliku \textit{docker-compose.yml} pozwala ustawić takie wartości
jak adres URL serwera czy używanie lokalizacji do ustawień języka.
Poniżej przedstawiono zawartość listingi z plikami źródłowymi wykorzystywanymi przez
te narzędzia.

\lstinputlisting[
  caption=Zawartość docker-compose.yml dla aplikacji klienckiej,
  label=lst:dockercomposeclient
]{docker-compose.client.txt}

\lstinputlisting[
  caption=Dockerfile aplikacji klienckiej,
  label=lst:dockerclient
]{dockerfile-client.txt}

Warto zauważyć, że adres wartość \textit{REACT\_APP\_API\_URL}
w pliku~\ref{lst:dockercomposeclient}musi być zgodna z wartością \textit{WEBUI\_URL}
w pliku~\ref{lst:dockerserver}.
Wykorzystanie konfiguracji opartej na narzędziach Docker, umożliwia większą
elastyczność w instalowaniu aplikacji klienckiej na różnych środowiskach bez potrzeby
jej ponownej kompilacji.

\subsection{Serwer LXC}
\label{subsec:konfiguracja-lxc}

W projekcie jako serwer LXC wykorzystano maszynę wirtualną na podstawie obrazu
\textit{Ubuntu Server 18.04.3 LTS}.
Jako hipernadzorcę wirtualizacji wykorzystano oprogramowanie \textit{VirtualBox}.
Po stworzeniu maszyny wirtualnej wykonano na nim kroki opisane
w rozdziale~\ref{ch:projekt_systemu} w sekcji~\ref{subsec:kofig}.
Następnie aby umożliwić prosty dostęp do połączenia się po SSH do maszyny wirtualnej
z poziomu lokalnej sieci oraz do kontenerów LXC znajdujących się na tej maszynie,
skonfigurowano adapter sieciowy dla maszyny wirtualnej.
W tym celu wybrano adapter zmostkowany (ang.\ \textit{bridged}).
Dzięki temu maszyna wirtualna będzie korzystać z tego samego interfejsu sieciowego
co maszyna gospodarza.
Poniżej na rys.~\ref{fig:vboxconf} przedstawiono zrzut z ekranu przedstawiający
konfigurację w programie \textit{VirtualBox}.

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.50]{figures/vboxconf.png}
  \caption{Konfiguracja sieci maszyny wirtualnej w programie VirtualBox}
  \label{fig:vboxconf}
\end{figure}

Wynikiem tej operacji powinno być wykorzystanie tego samego interfejsu sieciowego
gospodarza \textit{en8} co przedstawiono na poniższych listingach.

\lstinputlisting[
  caption=Konfiguracja interfejsu sieciowego maszyny gospodarza,
  label=lst:ifconfighost
]{ifconfighost.txt}

\lstinputlisting[
  caption=Konfiguracja interfejsu sieciowego maszyny wirtualnej,
  label=lst:ifconfigvirt
]{ifconfigvirt.txt}

Na podstawie listingów~\ref{lst:ifconfighost} oraz~\ref{lst:ifconfigvirt}
widać, że adres IP hosta to 10.122.18.125, maska podsieci 255.255.252.0, co
oznacza że adres sieci to 10.122.16.0/22.
Adres IP maszyny wirtualnej to 10.122.18.86, maska podsieci 255.255.252.0,
co również oznacza że adres sieci to 10.122.16.0/22.
Maszyna wirtualna i maszyna gospodarza są w tej samej sieci, co potwierdza
że konfiguracja adaptera mostkowego działa poprawnie.

\section{Relacyjna baza danych}
\label{sec:relacyjna-baza-danych}

Dane użytkowników i oraz ich powiązania z kontenerami są przechowywane
w relacyjnej bazie danych zarządzanej przez PostgreSQL\@.
Dzięki wykorzystaniu biblioteki Hibernate większość operacji,
struktura bazy danych generowana jest automatycznie, a jej obsługa
wykonana w aplikacji serwerowej.

\subsection{Schemat relacji}
\label{subsec:schemat-relacji}

Tabele wygenerowane zostały za pomocą biblioteki Hibernate będącej implementacją
specyfikacji JPA\@.
Schemat wygenerowanych tabel został przedstawiony poniżej na rysunku~\ref{fig:dbschema}.

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.55]{figures/dbschema.png}
  \caption{Schemat tabel relacyjnej bazy danych}
  \label{fig:dbschema}
\end{figure}

\subsection{Transakcje bazodanowe}
\label{subsec:transakcjeimpl}

Spring Data dostarcza specjalną adnotację dla języka Java \textit{@Transactional}.
Metody oznaczone tą adnotacją będą wykonywać operacje na relacyjnej bazie danych w sposób
transakcyjny.
Adnotacja \textit{@Transactional} jest dozwolona tylko dla obiektów zarządzanych przez
szkielet Spring.
Działanie adnotacji powoduje utworzenia aspektu dla oznaczonej tak metody, który
wywoła odpowiednie metody interfejsu JPA do utworzenia i zakończenia transakcji.

\lstinputlisting[
  caption=Konfiguracja interfejsu sieciowego maszyny wirtualnej,
  label=lst:transactions,
  language=Java,
]{transactions.txt}

Fragment programu~\ref{lst:transactions} przedstawia metodę usuwania użytkownika.
Została ona opatrzona adnotacją \textit{@Transactional} bez dodatkowych parametrów, co oznacza,
że zostanie wykorzystany domyślny poziom izolacji dla używanego RDBMS\@.
Dla PostgreSQL jest to poziom \textit{read committed}, który jest wystarczający dla tej operacji.

\subsection{ORM}
\label{subsec:orm}

ORM czyli mapowanie relacyjno-obiektowe zostało zrealizowane za pomocą adnotacji JPA\@.
Poniżej przedstawiono przykładową reprezentację tabeli poprzez obiekt języka Java i odpowiednie
adnotacje JPA\@.

\lstinputlisting[
  caption=Wykorzystanie JPA do mapowania relacyjno obiektowego,
  label=lst:usersmodel,
  language=Java,
]{usersmodel.txt}

Klasa dziedziczy z \textit{BaseModel}.
Jest to bazowa klasa dla wszystkich encji definiująca klucz główny oraz pole wersji.

\lstinputlisting[
  caption=Klaza bazowa dla wszystkich encji w systemie,
  label=lst:basemodel,
  language=Java,
]{basemodel.txt}

W załączonych fragmentach programów~\ref{lst:usersmodel} oraz~\ref{lst:basemodel} pojawia się wiele adnotacji.
Nie wszystkie z nich są związane z JPA\@.
Znaczenie najważniejszych adnotacji zostało opisane poniżej:

\begin{itemize}
  \item \textbf{@Entity}.
  Oznacza, że dana klasa reprezentuje encję w bazie danych.
  \item \textbf{@Table}.
  Specyfikuje na jaką tabelę ma być mapowana klasa oznaczona przez \textit{@Entity}.
  \item \textbf{@Id}.
  Oznacza, że pole jest kluczem głównym.
  \item \textbf{@Column}.
  Umożliwia dodatkowe opcje dla mapowanej kolumny.
  Jeśli pole nie jest oznaczone tą adnotacją, kolumna będzie miała ustawienia domyślne.
  \item \textbf{@GeneratedValue}.
  Strategia generowania kluczy głównych przez RDBMS\@.
  \item \textbf{@Version}.
  Oznacza pole wersji encji zarządzanej przez RDBMS\@.
  \item \textbf{@OneToMany}.
  Oznacza, mapowanie jeden do wielu.
  Dzięki temu możemy mapować relacje w bazie danych na powiązania pomiędzy obiektami.
  \item \textbf{@NotNull, @Size, @Email}.
  Nie są to adnotacje JPA\@.
  Są to adnotacje do walidacji wchodzące skład \textit{Bean Validation API}.
\end{itemize}

\section{Integracja z serwerem LXC}
\label{sec:komunikacja-z-serwerem-lxc}

Kluczowym elementem systemu było zrealizowanie komunikacji z serwerem składującym
kontenery LXC\@.
Całość logiki tej komunikacji zrealizowana jest w aplikacji serwerowej.
Obejmuje ona wiele aspektów, takich jak konfiguracja szablonów komend, asynchroniczne
wykonanie oraz wykonanie poleceń powłoki poprzez SSH\@.

\subsection{Szablony komend}
\label{subsec:szablony-komend}

Pierwszą częścią implementacji jest zdefiniowanie poleceń powłoki które będą uruchamiane
na serwerze LXC\@.
Zostały one zdefiniowane w konfiguracji aplikacji.

\lstinputlisting[
  caption=Frament pliku konfiguracyjnego \textit{appliaction.yml} z szablonami poleceń,
  label=lst:lxccmds,
]{lxccmds.txt}

Fragment programu~\ref{lst:lxccmds} przedstawia zdefiniowane szablony poleceń uruchamiane
przez program LXD\@.
Komendy zawierają fragmenty \textit{\%s}, które podczas działania programu są zamieniane
na określone wartości, np.\ nazwę kontenera czy numer portu.
Znaczenie poszczególnych wartości konfiguracji:

\begin{itemize}
  \item \textbf{copy}.
  Określa polecenie do klonowania kontenerów.
  Parametry \textit{\%s} są zamieniane odpowiednio na nazwę kontenera do
  sklonowania i nazwę nowego kontenera.
  \item \textbf{start}.
  Określa polecenie do uruchamiania kontenerów.
  Parametr \textit{\%s} jest zamieniany na nazwę kontenera do uruchomienia.
  \item \textbf{stop}.
  Określa polecenie do wyłączania kontenerów.
  Parametr \textit{\%s} jest zamieniany na nazwę kontenera do wyłączenia.
  \item \textbf{routing}.
  Określa polecenie do tworzenia wirtualnego urządzenia za pomocą którego zrealizowane
  zostanie mapowanie portów kontenera na porty maszyny gospodarza.
  Pierwsze dwa parametry \textit{\%s} są zamieniane na nazwę kontenera dla którego
  dodawane jest urządzenie.
  Dwa następne są zamieniane na wartości portów.
  Dla \textit{listen} wstawiana jest wartość portu gospodarza, dla \textit{connect}
  wartość portu kontenera.
  Po wykonaniu takiej komendy, port gospodarza połączony z portem kontenera.
  Umożliwia to połączenia się poprzez SSH bezpośrednio do wybranego kontenera
  wykorzystując adres IP serwera oraz tak skonfigurowany port.
  \item \textbf{cmdRunner}.
  W systemie istnieje możliwość wielu implementacji interfejsu do uruchamiania
  komend na serwerze LXC\@.
  Opcja \textit{sshpwd} oznacza implementację interfejsu która łączy się do serwera poprzez
  SSH z wykorzystaniem hasła.
  Istnieje również np.\ opcja \textit{mock}, która udaje wykonywanie komend na zdalnym
  serwerze, jest to przydatne podczas testów aplikacji, gdy nie mamy dostępu do zdalnego
  serwera.
\end{itemize}

\subsection{Asynchroniczne wykonanie}
\label{subsec:asynchroniczne-wykonanie}

Wszystkie metody w serwisach które wykonują operacje na kontenerach LXC,
są wykonywane asynchronicznie.
Do asynchronicznego wykonania wykorzystano szkielet Spring.
Metody asynchronicznie są oznaczone adnotacja \textit{@Async}.
Spring uruchomi takie metody na osobnym wątku ze skonfigurowanej puli wątków.

Pula wątków tworzy trwałe wątki które nie są zabijane przez system operacyjny
po ukończeniu jednej operacji.
Takie wątki istnieją przez cały czas podczas działania aplikacji.
Wykorzystanie puli wątków jest metodą optymalizacji aplikacji ponieważ
tworzenie nowego wątku za każdym razem jest bardzo kosztowne.
Jeśli ilość wątków w puli będzie zbyt mała, część zadań zostanie automatycznie
skolejkowana.

\lstinputlisting[
  caption=Metoda asynchroniczna pobierająca status kontenera,
  label=lst:lxcasync,
  language=Java,
]{lxcasync.txt}

\lstinputlisting[
  caption=Konfiguracja puli wątków,
  label=lst:threadpool,
  language=Java,
]{threadpool.txt}

We fragmencie programu~\ref{lst:lxcasync} widać, że metoda pobierająca status
jest typu \textit{void}.
Dzieje się tak ponieważ odpowiedź o statusie przetwarzana jest przez \textit{message processor},
przekazany jako obiekt o nazwie \textit{processor} do obiektu \textit{LxcGenericTask}.

\lstinputlisting[
  caption=Klasa reprezentująca \textit{message processor},
  label=lst:msgprocessor,
  language=Java,
]{msgprocessor.txt}

We fragmencie programu~\ref{lst:msgprocessor} widać, że mechanizm jest zaimplementowany
za pomocą klasy \textit{EmitterProcessor}.
Jest to klasa z biblioteki wspierającej paradygmat programowania reaktywnego - \textit{Project Reactor}.
Zastosowanie interfejsu \textit{IProcessor} pozwoliło brak zależności metod serwisowych od biblioteki
\textit{Project Reactor}.
Adnotacja \textit{@Component} zapewnia, że jest to obiekt zarządzany przez szkielet spring.
Podczas jego wstrzykiwania w różnych klas, będzie dostarczana ta sama instancja tego obiektu.
Rolą jaką pełni \textit{IProcessor} jest otrzymywanie wiadomości o statusie zadania
i przekazywanie tych wiadomości w reaktywny sposób do obiektów które się do niego zasubskrybują.

\lstinputlisting[
  caption=Wysyłanie wiadomości przez \textit{message processor},
  label=lst:msgsend,
  language=Java,
]{msgsend.txt}

Fragment programu~\ref{lst:msgsend} zawiera fragment klasy \textit{LxcGenericTask}, która
wysyła wiadomość do procesora aktualnym stanie wykonywanego zadania, za pomocą obiektu
\textit{processor}, który implementuje interfejs \textit{IProcessor}.
Natomiast logika przetwarzania wiadomości jest umieszczona w osobnej klasie w kontrolerach.

\lstinputlisting[
  caption=Subskrypcja do wiadomości wysłanych przez \textit{message processor},
  label=lst:msgsub,
  language=Java,
]{msgsub.txt}

Subskrypcja wykonywana jest tylko raz, w konstruktorze kontrolera.
Dostarczana jest tam metoda która konsumuje nowe wiadomości i wysyła je do gniazda sieciowego.
Warto zauważyć, że istnieje separacja pomiędzy wysyłaniem powiadomień dla
użytkownika i administratora.
Do użytkownika wysyłana są tylko powiadomienia o rozpoczętych przez niego akcji, natomiast
do administratora wysyłane są powiadomienia o wszystkich akcjach.

Adnotacja \textit{@Autowired} zapewnia wstrzyknięcie odpowiedniej instancji obiektów, w tym
instancji obiektu implementującego interfejs \textit{IProcessor}, jest to ta sama
instancja która była wykorzystana w klasie \textit{LxcGenericTask}

\clearpage
